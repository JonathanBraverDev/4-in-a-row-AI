(define-struct state (board player parent))
(define B1 '((- - - - - - -)
             (- - - - - - -)
             (- - - - - - -)
             (- - - - - - -)
             (- - - - - - -)
             (- - - - - - -)))
(define S (make-state B1 'X 'none))


(define (move state column)
  (cond
    ((equal? (getTileAt (state-board state) column 0) '-) (make-state (updateBoard (state-board state) column (lowestFreeSpotInColumn (state-board state) column 0) (state-player state)) (opponentMarker (state-player state)) state))
    (else #F)))

(define (lowestFreeSpotInColumn B column depth)
  (cond
    ((= depth 6) 5)
    ((equal? (getTileAt B column depth) '-) (lowestFreeSpotInColumn B column (add1 depth)))
    (else (sub1 depth))))

(define (opponentMarker marker)
  (cond
    ((equal? marker 'O) 'X)
    (else 'O)))


(define (possibleMoves state column) ;defult column is 0
  (cond
    ((= column 7) '())
    ((move state column) (cons (move state column) (possibleMoves state (add1 column))))
    (else (possibleMoves state (add1 column)))))

(define (testAllMoves depth targetDepth movesL) ;WIP
  (cond
    ((= depth targetDepth) (calcValue movesL)) ;MISSING FINCTION
    ((empty? movesL) 'ERR-NO-MOVES)
    ((empty? (rest movesL)) (testAllMoves (add1 depth) targetDepth (append (rest movesL) (possibleMoves (first movesL) 0))))
    ((not (equal? (state-player (first movesL)) (state-player (second movesL)))) (testAllMoves (add1 depth) targetDepth (append (rest movesL) (possibleMoves (first movesL) 0))))
    (else (testAllMoves depth targetDepth (append (rest movesL) (possibleMoves (first movesL) 0))))))

(define (calcValue movesL) ;will run a function to give each move a value and compare the best move for the player in the parent state
  (cond
    ((not movesL) 'FUCK)
;    (else (printStates movesL))))
    (else movesL)))

(define (playTest state)
;  (printState state)
  (cond
    ((and (state? (state-parent state)) (win state 0 0 (state-player (state-parent state)))) 1)
    ((empty? (possibleMoves state 0)) (display "TIE  ") 0)
    (else (playTest (randomIndexFrom (possibleMoves state 0))))))

(define (win state X Y player)
  (cond
    ((= Y 6) #F)
    ((not (legalTile? X Y)) (win state 0 (add1 Y) player))
    ((and (< X 4)
          (equal? (list-ref (list-ref (state-board state) Y) X) player)
          (equal? (list-ref (list-ref (state-board state) Y) (+ 1 X)) player)
          (equal? (list-ref (list-ref (state-board state) Y) (+ 2 X)) player)
          (equal? (list-ref (list-ref (state-board state) Y) (+ 3 X)) player)) #T)
    ((and (< Y 3)
          (equal? (list-ref (list-ref (state-board state) Y) X) player)
          (equal? (list-ref (list-ref (state-board state) (+ 1 Y)) X) player)
          (equal? (list-ref (list-ref (state-board state) (+ 2 Y)) X) player)
          (equal? (list-ref (list-ref (state-board state) (+ 3 Y)) X) player)) #T)
    ((and (< Y 3) (< X 4)
          (equal? (list-ref (list-ref (state-board state) Y) X) player)
          (equal? (list-ref (list-ref (state-board state) (+ 1 Y)) (+ 1 X)) player)
          (equal? (list-ref (list-ref (state-board state) (+ 2 Y)) (+ 2 X)) player)
          (equal? (list-ref (list-ref (state-board state) (+ 3 Y)) (+ 3 X)) player)) #T)
    ((and (> Y 3) (< X 4)
          (equal? (list-ref (list-ref (state-board state) Y) X) player)
          (equal? (list-ref (list-ref (state-board state) (- Y 1)) (+ 1 X)) player)
          (equal? (list-ref (list-ref (state-board state) (- Y 2)) (+ 2 X)) player)
          (equal? (list-ref (list-ref (state-board state) (- Y 3)) (+ 3 X)) player)) #T)
    (else (win state (add1 X) Y player))))
    
(define (legalTile? X Y)
  (cond
    ((and (< -1 X) (> 7 X) (< -1 Y) (> 6 Y)) #T)
    (else #F)))

(define (printBoard B)
  (cond
   ((not (empty? (rest B))) (println (first B)) (printBoard (rest B)))
   ((empty? (rest B)) (println (first B)))))

(define (findInBoard target B X Y)
  (cond
    ((equal? (getTileAt B (list X Y)) target) (list X Y))
    ((> Y (sub1 (length B))) #F)
    ((= X (sub1 (length (first B)))) (findInBoard target B 0 (add1 Y)))
    (else (findInBoard target B (add1 X) Y))))

(define (findInList target L)
  (cond
    ((empty? L) #F)
    ((equal? (state-board (first L)) (state-board target)) #T)
    (else (findInList target (rest L)))))

(define (outOfBounds? B X Y)
  (cond
    ((or (> 0 X) (> 0 Y) (< (sub1 (length (first B))) X) (< (sub1 (length B)) Y)) #T)
    (else #F)))

(define (updateBoard B Xpos Ypos input)
  (cond
    ((= Ypos 0) (cons (updateCol (first B) Xpos input) (rest B)))
    (else (cons (first B) (updateBoard (rest B) Xpos (sub1 Ypos) input)))))


(define (updateCol L Xpos input)
  (cond
    ((= Xpos 0) (cons input (rest L)))
    (else (cons (first L) (updateCol (rest L) (sub1 Xpos) input)))))


(define (getX input)
  (first input))


(define (getY input)
  (second input))


(define (getTileAt B Xpos Ypos)
  (list-ref (list-ref B Ypos) Xpos))

(define (countAttacks Lindex)
  (cond
    ((= index (length L)) 0)
    (else (+ (attackerCount Lindex) (countAttacks L(add1 index))))))

(define (attackerCount LqueenNum)
  (+ (countDiaAttacks LqueenNum 0) (rowAttacks LqueenNum 0)))

(define (rowAttacks LqueenNum index)
  (cond
    ((= index (length L)) 0)
    ((= index queenNum) (rowAttacks LqueenNum (add1 index)))
    ((= (list-ref LqueenNum) (list-ref Lindex)) (add1 (rowAttacks LqueenNum (add1 index))))
    (else (rowAttacks LqueenNum (add1 index)))))

(define (countDiaAttacks LqueenNum index)
  (cond
    ((= index (length L)) 0)
    ((= index queenNum) (countDiaAttacks LqueenNum (add1 index)))
    ((= (list-ref LqueenNum) (+ (list-ref Lindex) (abs (- index queenNum)))) (add1 (countDiaAttacks LqueenNum (add1 index))))
    ((= (list-ref LqueenNum) (- (list-ref Lindex) (abs (- index queenNum)))) (add1 (countDiaAttacks LqueenNum (add1 index))))
    (else (countDiaAttacks LqueenNum (add1 index)))))

(define (listUntill L index counter)
  (cond
    ((= index 0) '())
    ((= (sub1 (length L)) index) (rest L))
    ((= counter index) '())
    (else (cons (list-ref L counter) (listUntill L index (add1 counter))))))

(define (listFrom L index)
  (cond 
    ((= index 0) L)
    ((= (length L) index) '())
    (else (cons (list-ref L index) (listFrom L (add1 index))))))

(define (randomIndexFrom L)
  (list-ref L (random (length L))))

(define (calcForEach Lindex)
  (cond
    ((= index (length L)) '())
    (else (cons (countAttacks (list-ref Lindex) 0) (calcForEach L(add1 index))))))

(define (printState state)
  (printBoard (state-board state))
  (displayln "next turn is:")
  (println (state-player state))
  (newline))

(define (printStates L)
  (cond
    ((empty? L) 'done)
    (else (printState (first L)) (printStates (rest L)))))

(define (tieRate numOfRuns ties wins) ;just for fun... defult is 0 on ties and wins
  (cond
    ((= 0 numOfRuns) (newline) (* (/ ties wins) 100))
    ((= (playTest S) 1) (tieRate (sub1 numOfRuns) ties (add1 wins)))
    (else (tieRate (sub1 numOfRuns) (add1 ties) wins))))
    
  

(define-struct state (board score player parent))
(define B1 '((- - - - - - -)
             (- - - - - - -)
             (- - - - - - -)
             (- - - - - - -)
             (- - - - - - -)
             (- - - - - - -))) 
(define S (make-state B1 0 'X 'none))

(define B2 '((- - - - - - -)
             (- - - - - - -)
             (- - - - - - -)
             (O - - X - - -)
             (O - - X - - -)
             (O - - X - - -)))

(define B2.1 '((- - - - - - -)
               (- - - - - - -)
               (- - - - - - -)
               (- - - X - - -)
               (O - - X - - -)
               (O - - X - - -)))

(define S2.1 (make-state B2.1 0 'O 'none))
(define S2 (make-state B2 0 'X S2.1))

;(0,0) is the top left, (6,5) in the bottom rigth (using double list-ref Y is entered first (so (list-ref  (list-ref (state-board X) 5) 6) is (6,5))
;(display "enter the bot's search depth")
;(define searchDepth (read))


(define (move state column)
  (cond
    ((equal? (getTileAt (state-board state) column 0) '-) (calcScore (updateBoard (state-board state) column (lowestFreeSpotInColumn (state-board state) column 0) (state-player state)) (state-player state) state))
    (else #F)))

(define (calcScore B player parent) ;for now just win detection fo each player
  (cond
    ((win? B 0 0 'X) (make-state B +inf.0 (opponentMarker player) parent))
    ((win? B 0 0 'O) (make-state B -inf.0 (opponentMarker player) parent))
    (else (make-state B (calcScore2 B player) (opponentMarker player) parent))))

(define (calcScore2 B player)
  (define points (- (+ (* 3 (countThrees B 0 0 (opponentMarker player) 0))  ;3 'points' for threes 
                       (* 1 (countPairs B 0 0 (opponentMarker player) 0)))  ;1 'point' for pairs (with overlaps)
                    (+ (* 3 (countThrees B 0 0 player 0)) ;enemy score
                       (* 1 (countPairs B 0 0 player 0)))))
  (cond
    ((equal? player 'O) (* -1 points))
    (else points)))

(define (countThrees board X Y player numOfThrees)
    (cond
    ((= Y 6) numOfThrees)
    ((not (legalTile? X Y)) (countThrees board 0 (add1 Y) player numOfThrees))
    ((and (< X 5)
          (equal? (list-ref (list-ref board Y) X) player)
          (equal? (list-ref (list-ref board Y) (+ 1 X)) player)
          (equal? (list-ref (list-ref board Y) (+ 2 X)) player)) (countThrees board (add1 X) Y player (add1 numOfThrees)))
    ((and (< Y 4)
          (equal? (list-ref (list-ref board Y) X) player)
          (equal? (list-ref (list-ref board (+ 1 Y)) X) player)
          (equal? (list-ref (list-ref board (+ 2 Y)) X) player)) (countThrees board (add1 X) Y player (add1 numOfThrees)))
    ((and (< Y 4) (< X 5)
          (equal? (list-ref (list-ref board Y) X) player)
          (equal? (list-ref (list-ref board (+ 1 Y)) (+ 1 X)) player)
          (equal? (list-ref (list-ref board (+ 2 Y)) (+ 2 X)) player)) (countThrees board (add1 X) Y player (add1 numOfThrees)))
    ((and (> Y 4) (< X 5)
          (equal? (list-ref (list-ref board Y) X) player)
          (equal? (list-ref (list-ref board (- Y 1)) (+ 1 X)) player)
          (equal? (list-ref (list-ref board (- Y 2)) (+ 2 X)) player)) (countThrees board (add1 X) Y player (add1 numOfThrees)))
    (else (countThrees board (add1 X) Y player numOfThrees))))

(define (countPairs board X Y player numOfPaires)
    (cond
    ((= Y 6) numOfPaires)
    ((not (legalTile? X Y)) (countPairs board 0 (add1 Y) player numOfPaires))
    ((and (< X 6)
          (equal? (list-ref (list-ref board Y) X) player)
          (equal? (list-ref (list-ref board Y) (+ 1 X)) player)) (countPairs board (add1 X) Y player (add1 numOfPaires)))
    ((and (< Y 5)
          (equal? (list-ref (list-ref board Y) X) player)
          (equal? (list-ref (list-ref board (+ 1 Y)) X) player)) (countPairs board (add1 X) Y player (add1 numOfPaires)))
    ((and (< Y 5) (< X 6)
          (equal? (list-ref (list-ref board Y) X) player)
          (equal? (list-ref (list-ref board (+ 1 Y)) (+ 1 X)) player)) (countPairs board (add1 X) Y player (add1 numOfPaires)))
    ((and (> Y 5) (< X 6)
          (equal? (list-ref (list-ref board Y) X) player)
          (equal? (list-ref (list-ref board (- Y 1)) (+ 1 X)) player)) (countPairs board (add1 X) Y player (add1 numOfPaires)))
    (else (countPairs board (add1 X) Y player numOfPaires))))

(define (Min movesL index bestIndex) ;movesL is (possibleMoves state 0), index is 0, bestIndex is '(0)
  (cond
    ((empty? movesL) 'tie)
    ((> index (sub1 (length movesL))) (list-ref movesL (randomIndexFrom bestIndex)))
    ((= (state-score (list-ref movesL index)) (state-score (list-ref movesL (first bestIndex)))) (Min movesL (add1 index) (cons index bestIndex)))
    ((< (state-score (list-ref movesL index)) (state-score (list-ref movesL (first bestIndex)))) (Min movesL (add1 index) (list index)))
    (else (Min movesL (add1 index) bestIndex))))

(define (Max movesL index bestIndex) ;movesL is (possibleMoves state 0), index is 0, bestIndex is '(0)
  (cond
    ((empty? movesL) 'tie)
    ((> index (sub1 (length movesL))) (list-ref movesL (randomIndexFrom bestIndex)))
    ((= (state-score (list-ref movesL index)) (state-score (list-ref movesL (first bestIndex)))) (Max movesL (add1 index) (cons index bestIndex)))
    ((> (state-score (list-ref movesL index)) (state-score (list-ref movesL (first bestIndex)))) (Max movesL (add1 index) (list index)))
    (else (Max movesL (add1 index) bestIndex))))


;WIP ZONE
;-------------------------------------------------------------------------------------------------------------------------------

(define (deepUpdateScore movesL depth maxDepth) ;movesL is possible moves of the state, depth is more than 1, maxDepth is more than 2 and bigger than depth
  (cond
    ((= depth maxDepth) movesL)
    ((not (state? (first movesL))) (cons (deepUpdateScore (first movesL) depth maxDepth) (deepUpdateScore (rest movesL) depth maxDepth)))
    ((equal? (state-player (state-parent (first movesL))) 'X) (Max (deepUpdateScore (updateList (listHintChildren movesL) Min) (add1 depth) maxDepth) 0 '(0)))
    ((equal? (state-player (state-parent (first movesL))) 'O) (Min (deepUpdateScore (updateList (listHintChildren movesL) Max) (add1 depth) maxDepth) 0 '(0)))
    (else 'ERR-DUS)))

(define (listHintChildren movesL) ;hint child is the fist possible child of the state, he will update the score of his parent
  (cond
    ((empty? movesL) '())
    (else (cons (firstPossibleMove (first movesL) 0) (listHintChildren (rest movesL))))))

(define (updateParent state)
  (cond
    ((equal? (state-player (state-parent state)) 'X) (updateScore state Max))
    ((equal? (state-player (state-parent state)) 'O) (updateScore state Min))
    (else 'ERR-UP)))

(define (updateList movesL Min/Max) ;returns a list of all final move choices and updated scores
  (cond
    ((empty? (rest movesL)) (cons (updateScore (first movesL) (reverseMin/Max Min/Max)) '()))
    (else (cons (updateScore (first movesL) (reverseMin/Max Min/Max)) (updateList (rest movesL) (reverseMin/Max Min/Max))))))

(define (updateScore state Min/Max)
  (cond
    ((or (= -inf.0 (state-score state)) (= +inf.0 (state-score state))) state)
    (else (make-state (state-board (Min/Max (possibleMoves (state-parent state) 0) 0 '(0))) (state-score (Min/Max (possibleMoves (state-parent state) 0) 0 '(0))) (state-player state) (state-parent state)))))

;-------------------------------------------------------------------------------------------------------------------------------
;WIP ZONE



;TST ZONE
;-------------------------------------------------------------------------------------------------------------------------------

(define (allMovesUntillDepth statesL maxDepth) ;working
  (cond
    ((= maxDepth 0) statesL)
    ((and (not (empty? (rest statesL))) (not (equal? (state-player (first statesL)) (state-player (second statesL))))) (allMovesUntillDepth (append (rest statesL) (possibleMoves (first statesL) 0)) (sub1 maxDepth)))
    ((empty? (rest statesL)) (allMovesUntillDepth (possibleMoves (first statesL) 0) (sub1 maxDepth)))
    (else (allMovesUntillDepth (append (rest statesL) (possibleMoves (first statesL) 0)) maxDepth))))

(define (bestMove state depth) ;working 
  (setNewScore (allMovesUntillDepth (list state) depth)))


(define (setNewScore statesL)
  (define player (state-player (first statesL)))
  (define firstGroup (movesWithSameParent statesL))
  (cond
    ((and (< 7 (length statesL)) (not (equal? firstGroup statesL))) (setNewScore (append (listFrom statesL (length firstGroup)) (list (updateParent (first firstGroup))))))
    ;    ((and (< 7 (length statesL)) (equal? player 'X)) (print 1) (setNewScore (append (listFrom statesL (length firstGroup)) (list (updateParent (first firstGroup)))))) ;7 in te max ammound of moves in te game
    ;    ((and (< 7 (length statesL)) (equal? player 'O)) (print 2) (setNewScore (append (listFrom statesL (length firstGroup)) (list (updateParent (first firstGroup))))))
    ;    ((and (not (equal? firstGroup statesL)) (equal? player 'X)) (print 3) (setNewScore (append (listFrom statesL (length firstGroup)) (list (updateParent (first firstGroup))))))
    ;    ((and (not (equal? firstGroup statesL)) (equal? player 'O)) (print 4) (setNewScore (append (listFrom statesL (length firstGroup)) (list (updateParent (first firstGroup))))))
    (else (finalScore statesL player))))


(define (movesWithSameParent statesL) ;working
  (cond
    ((empty? (rest statesL)) (list (first statesL)))
    ((not (equal? (state-parent (first statesL)) (state-parent (second statesL)))) (list (first statesL)))
    (else (cons (first statesL) (movesWithSameParent (rest statesL))))))

(define (finalScore statesL player)
  (cond
    ((equal? player 'X) (Min statesL  0 '(0)))
    ((equal? player 'O) (Max statesL  0 '(0)))
    (else 'ERR-FS)))

(define (updateParent state)
  (cond
    ((equal? (state-player (state-parent state)) 'X) (updateScore (state-parent state) Min))
    ((equal? (state-player (state-parent state)) 'O) (updateScore (state-parent state) Max))
    (else 'ERR-UP)))

(define (updateScore state Min/Max)
  (cond
    ((or (= -inf.0 (state-score state)) (= +inf.0 (state-score state))) state)
    (else (make-state (state-board state) (state-score (Min/Max (possibleMoves state 0) 0 '(0))) (state-player state) state))))

;-------------------------------------------------------------------------------------------------------------------------------
;TST ZONE


;game modes: (WIP)

(define (PvE state)
  (printState state)
  (cond
    ((and (state? (state-parent state)) (win? (state-board state) 0 0 (state-player (state-parent state)))) (print (state-player (state-parent state))) (display " WON"))
    ((empty? (possibleMoves state 0)) (print 'TIE) 0)
    ((equal? (state-player state) 'X) (display "enter your move (0-6) ") (newline) (PvE (move state (read))))
    (else (PvE (bestMove state 2))))) ;only a temporary solution, bot cant srart

(define (playTest state) ;defult is S,Max ;working
  (printState state)
  (cond
    ((and (state? (state-parent state)) (win? (state-board state) 0 0 'X)) (displayln "X WON") 1)
    ((and (state? (state-parent state)) (win? (state-board state) 0 0 'O)) (displayln "O WON") 2)
    ((empty? (possibleMoves state 0)) (print 'TIE) 0)
    (else (playTest (bestMove state 2)))))


;working:

(define (listFrom L index) ;NOTE: indexing nums, starts from 0 NOT 1 like listUntill (intesionally, to 'miss' one entry given the same number)
  (cond 
    ((= index 0) L)
    ((= (length L) index) '())
    (else (cons (list-ref L index) (listFrom L (add1 index))))))

(define (listUntill L index counter) ;index not 0 and lower than list length, index is in humen nums (6 will retuen the fisrt 6, not 7 indexes)
  (cond
    ((= counter index) '())
    ((= (sub1 (length L)) index) (rest L))
    (else (cons (list-ref L counter) (listUntill L index (add1 counter))))))

(define (reverseMin/Max Min/Max)
  (cond
    ((equal? Min/Max Min) Max)
    (else Min)))

(define (mod2 num)
  (cond
    ((< num 2) num)
    (else (mod2 (- num 2)))))

(define (lowestFreeSpotInColumn B column depth)
  (cond
    ((= depth 6) 5)
    ((equal? (getTileAt B column depth) '-) (lowestFreeSpotInColumn B column (add1 depth)))
    (else (sub1 depth))))

(define (opponentMarker marker)
  (cond
    ((equal? marker 'O) 'X)
    (else 'O)))


(define (possibleMoves state column) ;defult column is 0
  (cond
    ((= column 7) '())
    ((move state column) (cons (move state column) (possibleMoves state (add1 column))))
    (else (possibleMoves state (add1 column)))))

(define (firstPossibleMove state column) ;defult column is 0
  (cond
    ((= column 7) '())
    ((move state column) (move state column))
    (else (possibleMoves state (add1 column)))))


(define (win? board X Y player)
  (cond
    ((= Y 6) #F)
    ((not (legalTile? X Y)) (win? board 0 (add1 Y) player))
    ((and (< X 4)
          (equal? (list-ref (list-ref board Y) X) player)
          (equal? (list-ref (list-ref board Y) (+ 1 X)) player)
          (equal? (list-ref (list-ref board Y) (+ 2 X)) player)
          (equal? (list-ref (list-ref board Y) (+ 3 X)) player)) #T)
    ((and (< Y 3)
          (equal? (list-ref (list-ref board Y) X) player)
          (equal? (list-ref (list-ref board (+ 1 Y)) X) player)
          (equal? (list-ref (list-ref board (+ 2 Y)) X) player)
          (equal? (list-ref (list-ref board (+ 3 Y)) X) player)) #T)
    ((and (< Y 3) (< X 4)
          (equal? (list-ref (list-ref board Y) X) player)
          (equal? (list-ref (list-ref board (+ 1 Y)) (+ 1 X)) player)
          (equal? (list-ref (list-ref board (+ 2 Y)) (+ 2 X)) player)
          (equal? (list-ref (list-ref board (+ 3 Y)) (+ 3 X)) player)) #T)
    ((and (> Y 3) (< X 4)
          (equal? (list-ref (list-ref board Y) X) player)
          (equal? (list-ref (list-ref board (- Y 1)) (+ 1 X)) player)
          (equal? (list-ref (list-ref board (- Y 2)) (+ 2 X)) player)
          (equal? (list-ref (list-ref board (- Y 3)) (+ 3 X)) player)) #T)
    (else (win? board (add1 X) Y player))))
    
(define (legalTile? X Y)
  (cond
    ((and (< -1 X) (> 7 X) (< -1 Y) (> 6 Y)) #T)
    (else #F)))

(define (printBoard B)
  (cond
    ((not (empty? (rest B))) (println (first B)) (printBoard (rest B)))
    ((empty? (rest B)) (println (first B)))))

(define (findInBoard target B X Y)
  (cond
    ((equal? (getTileAt B (list X Y)) target) (list X Y))
    ((> Y (sub1 (length B))) #F)
    ((= X (sub1 (length (first B)))) (findInBoard target B 0 (add1 Y)))
    (else (findInBoard target B (add1 X) Y))))

(define (findInList target L)
  (cond
    ((empty? L) #F)
    ((equal? (state-board (first L)) (state-board target)) #T)
    (else (findInList target (rest L)))))

(define (updateBoard B Xpos Ypos input)
  (cond
    ((= Ypos 0) (cons (updateCol (first B) Xpos input) (rest B)))
    (else (cons (first B) (updateBoard (rest B) Xpos (sub1 Ypos) input)))))


(define (updateCol L Xpos input)
  (cond
    ((= Xpos 0) (cons input (rest L)))
    (else (cons (first L) (updateCol (rest L) (sub1 Xpos) input)))))


(define (getX input)
  (first input))


(define (getY input)
  (second input))


(define (getTileAt B Xpos Ypos)
  (list-ref (list-ref B Ypos) Xpos))

(define (randomIndexFrom L)
  (list-ref L (random (length L))))

(define (printState state)
  (printBoard (state-board state))
  (display "score: ") (displayln (state-score state))
  (displayln "next turn is:")
  (println (state-player state))
  (newline))

(define (printStates L)
  (cond
    ((empty? L) 'done)
    (else (printState (first L)) (printStates (rest L)))))

(define (runForEach L function input) ;for single defult input functions
  (cond
    ((empty? (rest L)) (function (first L) input))
    (else (append (function (first L) input) (runForEach (rest L) function input)))))
      

(define (winRateCalc numOfRuns totalGames ties Xwins) ;just for fun... defult is 0 on all inputs, returns the winrate from X's rpespective
  (define result (playTest S))
  (cond
    ((= 0 numOfRuns) (newline) (display "tie count: ") (println ties) (* (/ Xwins totalGames) 100))
    ((= result 1) (winRateCalc (sub1 numOfRuns) totalGames ties (add1 Xwins)))
    ((= result 2) (winRateCalc (sub1 numOfRuns) totalGames ties Xwins))
    (else (winRateCalc (sub1 numOfRuns) totalGames (add1 ties) Xwins))))

(define (winRate player games)
  (cond
    ((equal? player 'X) (winRateCalc games games 0 0))
    ((equal? player 'O) (- 100 (winRateCalc games games 0 0)))
    (else 'ERR-winRate-unknown-player)))
                     
    

;maybe useful:

(define (countAttacks Lindex)
  (cond
    ((= index (length L)) 0)
    (else (+ (attackerCount Lindex) (countAttacks L(add1 index))))))

(define (attackerCount LqueenNum)
  (+ (countDiaAttacks LqueenNum 0) (rowAttacks LqueenNum 0)))

(define (rowAttacks LqueenNum index)
  (cond
    ((= index (length L)) 0)
    ((= index queenNum) (rowAttacks LqueenNum (add1 index)))
    ((= (list-ref LqueenNum) (list-ref Lindex)) (add1 (rowAttacks LqueenNum (add1 index))))
    (else (rowAttacks LqueenNum (add1 index)))))

(define (countDiaAttacks LqueenNum index)
  (cond
    ((= index (length L)) 0)
    ((= index queenNum) (countDiaAttacks LqueenNum (add1 index)))
    ((= (list-ref LqueenNum) (+ (list-ref Lindex) (abs (- index queenNum)))) (add1 (countDiaAttacks LqueenNum (add1 index))))
    ((= (list-ref LqueenNum) (- (list-ref Lindex) (abs (- index queenNum)))) (add1 (countDiaAttacks LqueenNum (add1 index))))
    (else (countDiaAttacks LqueenNum (add1 index)))))
    

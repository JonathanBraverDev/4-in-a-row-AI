(define-struct state (board score player parent))
(define B1 '((- - - - - - -)
             (- - - - - - -)
             (- - - - - - -)
             (- - - - - - -)
             (- - - - - - -)
             (- - - - - - -)))
(define S (make-state B1 0 'X 'none))

(define B2 '((- - - - - - -)
             (- - - - - - -)
             (- - - - - - -)
             (O - - X - - -)
             (O - - X - - -)
             (O - - X - - -)))

(define B2.1 '((- - - - - - -)
               (- - - - - - -)
               (- - - - - - -)
               (- - - X - - -)
               (O - - X - - -)
               (O - - X - - -)))

(define S2 (make-state B2 0 'X (make-state B2.1 0 'O 'none)))

;(display "enter the bot's search depth")
;(define searchDepth (read))


(define (move state column)
  (cond
    ((equal? (getTileAt (state-board state) column 0) '-) (calcScore (updateBoard (state-board state) column (lowestFreeSpotInColumn (state-board state) column 0) (state-player state)) (state-player state) state))
    (else #F)))

(define (calcScore B player parent) ;for now just win detection fo each player
  (cond
    ((win? B 0 0 'X) (make-state B +inf.0 (opponentMarker player) parent))
    ((win? B 0 0 'O) (make-state B -inf.0 (opponentMarker player) parent))
    (else (make-state B 0 (opponentMarker player) parent))))

(define (Min movesL index bestIndex) ;movesL is (possibleMoves state 0), index is 0, bestIndex is '(0)
    (cond
    ((empty? movesL) 'tie)
    ((> index (sub1 (length movesL))) (list-ref movesL (randomIndexFrom bestIndex)))
    ((= (state-score (list-ref movesL index)) (state-score (list-ref movesL (first bestIndex)))) (Min movesL (add1 index) (cons index bestIndex)))
    ((< (state-score (list-ref movesL index)) (state-score (list-ref movesL (first bestIndex)))) (Min movesL (add1 index) (list index)))
    (else (Min movesL (add1 index) bestIndex))))

(define (Max movesL index bestIndex) ;movesL is (possibleMoves state 0), index is 0, bestIndex is '(0)
  (cond
    ((empty? movesL) 'tie)
    ((> index (sub1 (length movesL))) (list-ref movesL (randomIndexFrom bestIndex)))
    ((= (state-score (list-ref movesL index)) (state-score (list-ref movesL (first bestIndex)))) (Max movesL (add1 index) (cons index bestIndex)))
    ((> (state-score (list-ref movesL index)) (state-score (list-ref movesL (first bestIndex)))) (Max movesL (add1 index) (list index)))
    (else (Max movesL (add1 index) bestIndex))))

(define (dfs open depth maxDepth) ;open is possible moves, depth is 0 (so 0 0 means the bot only looks at the next move, 0 1 will make him look 2 moves)
  (cond
    ((empty? open) 'ERR-no-moves)
    ((= depth maxDepth) (finalBestMove open depth))
    ((= (mod2 depth) 0) (Max (dfsForEach open depth maxDepth Min) 0 '(0))) ;need to activate on player turn, not the depth
    ((= (mod2 depth) 1) (Min (dfsForEach open depth maxDepth Max) 0 '(0))) ;need to activate on player turn, not the depth
    (else 'else)))

;WIP ZONE
;-------------------------------------------------------------------------------------------------------------------------------
(define (updateScoreORIGIAL state stateDevs Min/Max) ;stateDevs is possible moves (not a very important imput...)
  (cond
    ((or (= -inf.0 (state-score state)) (= +inf.0 (state-score state))) state)
    (else (make-state (state-board state) (state-score (Min/Max stateDevs 0 '(0))) (state-player state) (state-parent state)))))

(define (deepUpdateScore state depth maxDepth) ;test of the update function
  (cond
     
    ((equal? (state-player state) 'X) (updateScore state (possibleMoves state 0) Max))
    ((equal? (state-player state) 'Y) (updateScore state (possibleMoves state 0) Min))
    (else 'ERR-DUS)))

(define (updateList movesL Min/Max) ;returns a list of all final move choices and updated scores
  (cond
    ((list? (first movesL)) (splitAndUpdate movesL Min/Max)) ;i'm only expecting list of of moves here, not some random bullshit 
    ((empty? (rest movesL)) (cons (updateScore (first movesL) (possibleMoves (first movesL) 0) (reverseMin/Max Min/Max)) '()))
    (else (cons (updateScore (first movesL) (possibleMoves (first movesL) 0) (reverseMin/Max Min/Max)) (updateList (rest movesL) (reverseMin/Max Min/Max))))))

(define (splitAndUpdate movesL Min/Max)
  (cond
    ((empty? (rest movesL)) (cons (updateList (first movesL) Min/Max) '())) ;it also makes sure that all moves are prossesed, triple layer lists will work just fine here
    (else (cons (updateList (first movesL) Min/Max) (splitAndUpdate (rest movesL) Min/Max)))))
    
(define (updateScore state stateDevs Min/Max) 
  (cond
    ((or (= -inf.0 (state-score state)) (= +inf.0 (state-score state))) state)
    (else (make-state (state-board state) (state-score (Min/Max stateDevs 0 '(0))) (state-player state) (state-parent state)))))
;-------------------------------------------------------------------------------------------------------------------------------
;WIP ZONE

(define (finalBestMove open depth)
  (cond
    ((= (mod2 depth) 0) (Max open 0 '(0)))
    ((= (mod2 depth) 1) (Min open 0 '(0)))
    (else 'ERR-final-move)))

(define (dfsForEach L depth maxDepth nextOP)
  (cond
    ((empty? (rest L)) (list (nextOP (dfs (possibleMoves (first L) 0) (add1 depth) maxDepth)  0 '(0))))
    (else (cons (nextOP (dfs (possibleMoves (first L) 0) (add1 depth) maxDepth)  0 '(0)) (dfsForEach (rest L) depth maxDepth nextOP)))))

;game modes: (WIP)

(define (PvE state)
  (printState state)
  (cond
    ((and (state? (state-parent state)) (win? (state-board state) 0 0 (state-player (state-parent state)))) (print (state-player (state-parent state))) (display " WON"))
    ((empty? (possibleMoves state 0)) (print 'TIE) 0)
    ((equal? (state-player state) 'X) (display "enter your move (0-6) ") (PvE (move state (read))))
    (else (PvE (Min (possibleMoves state 0) 0 '(0)))))) ;only a temporary solution, bot cant srart

(define (playTest state Min/Max) ;defult is S,Max ;working
  (printState state)
  (cond
    ((and (state? (state-parent state)) (win? (state-board state) 0 0 'X)) (displayln "X WON") 1)
    ((and (state? (state-parent state)) (win? (state-board state) 0 0 'O)) (displayln "O WON") 2)
    ((empty? (possibleMoves state 0)) (print 'TIE) 0)
    (else (playTest (Min/Max (possibleMoves state 0) 0 '(0)) (reverseMin/Max Min/Max)))))


;working:

(define (reverseMin/Max Min/Max)
  (cond
    ((equal? Min/Max Min) Max)
    (else Min)))

(define (mod2 num)
  (cond
    ((< num 2) num)
    (else (mod2 (- num 2)))))

(define (lowestFreeSpotInColumn B column depth)
  (cond
    ((= depth 6) 5)
    ((equal? (getTileAt B column depth) '-) (lowestFreeSpotInColumn B column (add1 depth)))
    (else (sub1 depth))))

(define (opponentMarker marker)
  (cond
    ((equal? marker 'O) 'X)
    (else 'O)))


(define (possibleMoves state column) ;defult column is 0
  (cond
    ((= column 7) '())
    ((move state column) (cons (move state column) (possibleMoves state (add1 column))))
    (else (possibleMoves state (add1 column)))))

(define (win? board X Y player)
  (cond
    ((= Y 6) #F)
    ((not (legalTile? X Y)) (win? board 0 (add1 Y) player))
    ((and (< X 4)
          (equal? (list-ref (list-ref board Y) X) player)
          (equal? (list-ref (list-ref board Y) (+ 1 X)) player)
          (equal? (list-ref (list-ref board Y) (+ 2 X)) player)
          (equal? (list-ref (list-ref board Y) (+ 3 X)) player)) #T)
    ((and (< Y 3)
          (equal? (list-ref (list-ref board Y) X) player)
          (equal? (list-ref (list-ref board (+ 1 Y)) X) player)
          (equal? (list-ref (list-ref board (+ 2 Y)) X) player)
          (equal? (list-ref (list-ref board (+ 3 Y)) X) player)) #T)
    ((and (< Y 3) (< X 4)
          (equal? (list-ref (list-ref board Y) X) player)
          (equal? (list-ref (list-ref board (+ 1 Y)) (+ 1 X)) player)
          (equal? (list-ref (list-ref board (+ 2 Y)) (+ 2 X)) player)
          (equal? (list-ref (list-ref board (+ 3 Y)) (+ 3 X)) player)) #T)
    ((and (> Y 3) (< X 4)
          (equal? (list-ref (list-ref board Y) X) player)
          (equal? (list-ref (list-ref board (- Y 1)) (+ 1 X)) player)
          (equal? (list-ref (list-ref board (- Y 2)) (+ 2 X)) player)
          (equal? (list-ref (list-ref board (- Y 3)) (+ 3 X)) player)) #T)
    (else (win? board (add1 X) Y player))))
    
(define (legalTile? X Y)
  (cond
    ((and (< -1 X) (> 7 X) (< -1 Y) (> 6 Y)) #T)
    (else #F)))

(define (printBoard B)
  (cond
   ((not (empty? (rest B))) (println (first B)) (printBoard (rest B)))
   ((empty? (rest B)) (println (first B)))))

(define (findInBoard target B X Y)
  (cond
    ((equal? (getTileAt B (list X Y)) target) (list X Y))
    ((> Y (sub1 (length B))) #F)
    ((= X (sub1 (length (first B)))) (findInBoard target B 0 (add1 Y)))
    (else (findInBoard target B (add1 X) Y))))

(define (findInList target L)
  (cond
    ((empty? L) #F)
    ((equal? (state-board (first L)) (state-board target)) #T)
    (else (findInList target (rest L)))))

(define (updateBoard B Xpos Ypos input)
  (cond
    ((= Ypos 0) (cons (updateCol (first B) Xpos input) (rest B)))
    (else (cons (first B) (updateBoard (rest B) Xpos (sub1 Ypos) input)))))


(define (updateCol L Xpos input)
  (cond
    ((= Xpos 0) (cons input (rest L)))
    (else (cons (first L) (updateCol (rest L) (sub1 Xpos) input)))))


(define (getX input)
  (first input))


(define (getY input)
  (second input))


(define (getTileAt B Xpos Ypos)
  (list-ref (list-ref B Ypos) Xpos))

(define (randomIndexFrom L)
  (list-ref L (random (length L))))

(define (printState state)
  (printBoard (state-board state))
  (display "score: ") (displayln (state-score state))
  (displayln "next turn is:")
  (println (state-player state))
  (newline))

(define (printStates L)
  (cond
    ((empty? L) 'done)
    (else (printState (first L)) (printStates (rest L)))))

(define (runForEach L function input) ;for single defult input functions
  (cond
    ((empty? (rest L)) (function (first L) input))
    (else (append (function (first L) input) (runForEach (rest L) function input)))))
      

(define (winRateCalc numOfRuns totalGames ties Xwins) ;just for fun... defult is 0 on all inputs, returns the winrate from X's rpespective
  (cond
    ((= 0 numOfRuns) (newline) (display "tie count: ") (println ties) (* (/ Xwins totalGames) 100))
    ((= (playTest S Max) 1) (winRateCalc (sub1 numOfRuns) totalGames ties (add1 Xwins)))
    ((= (playTest S Max) 2) (winRateCalc (sub1 numOfRuns) totalGames ties Xwins))
    (else (winRateCalc (sub1 numOfRuns) totalGames (add1 ties) Xwins))))

(define (winRate player games)
  (cond
    ((equal? player 'X) (winRateCalc games games 0 0))
    ((equal? player 'O) (- 100 (winRateCalc games games 0 0)))
    (else 'ERR-winRate-unknown-player)))
                     
    

;maybe useful:

(define (countAttacks Lindex)
  (cond
    ((= index (length L)) 0)
    (else (+ (attackerCount Lindex) (countAttacks L(add1 index))))))

(define (attackerCount LqueenNum)
  (+ (countDiaAttacks LqueenNum 0) (rowAttacks LqueenNum 0)))

(define (rowAttacks LqueenNum index)
  (cond
    ((= index (length L)) 0)
    ((= index queenNum) (rowAttacks LqueenNum (add1 index)))
    ((= (list-ref LqueenNum) (list-ref Lindex)) (add1 (rowAttacks LqueenNum (add1 index))))
    (else (rowAttacks LqueenNum (add1 index)))))

(define (countDiaAttacks LqueenNum index)
  (cond
    ((= index (length L)) 0)
    ((= index queenNum) (countDiaAttacks LqueenNum (add1 index)))
    ((= (list-ref LqueenNum) (+ (list-ref Lindex) (abs (- index queenNum)))) (add1 (countDiaAttacks LqueenNum (add1 index))))
    ((= (list-ref LqueenNum) (- (list-ref Lindex) (abs (- index queenNum)))) (add1 (countDiaAttacks LqueenNum (add1 index))))
    (else (countDiaAttacks LqueenNum (add1 index)))))
    
  

(define-struct state (board score player parent))
(define B1 '((- - - - - - -)
             (- - - - - - -)
             (- - - - - - -)
             (- - - - - - -)
             (- - - - - - -)
             (- - - - - - -)))
(define S (make-state B1 0 'X 'none))

(define B2 '((- - - - - - -)
             (- - - - - - -)
             (- - - - - - -)
             (O - - X - - -)
             (O - - X - - -)
             (O - - X - - -)))

(define B2.1 '((- - - - - - -)
               (- - - - - - -)
               (- - - - - - -)
               (- - - X - - -)
               (O - - X - - -)
               (O - - X - - -)))

(define S2 (make-state B2 0 'X (make-state B2.1 0 'O 'none)))

;(display "enter the bot's search depth")
;(define Sdepth (read))


(define (move state column)
  (cond
    ((equal? (getTileAt (state-board state) column 0) '-) (calcScore (updateBoard (state-board state) column (lowestFreeSpotInColumn (state-board state) column 0) (state-player state)) (state-player state) state))
    (else #F)))

(define (calcScore B player parent) ;for now just win/lose
  (cond
    ((win? B 0 0 player) (make-state B +inf.0 (opponentMarker player) parent))
    ((win? B 0 0 (opponentMarker player)) (newline) (make-state B -inf.0 (opponentMarker player) parent))
    (else (make-state B 0 (opponentMarker player) parent))))

(define (bestMove movesL index bestIndex) ;movesL is (possibleMoves state 0) index is 0 and bestIndex is '(0)
  (cond
    ((empty? movesL) 'tie)
    ((> index (- (length movesL) 2)) (list-ref movesL (randomIndexFrom bestIndex)))
    ((= (state-score (list-ref movesL index)) (state-score (list-ref movesL (first bestIndex)))) (bestMove movesL (add1 index) (cons index bestIndex)))
    ((> (state-score (list-ref movesL index)) (state-score (list-ref movesL (first bestIndex)))) (bestMove movesL (add1 index) (list index)))
    (else (bestMove movesL (add1 index) bestIndex))))

(define (develop state depth maxDepth open)
  (cond
    ((empty? open) state)
    ((< depth maxDepth) (bestMove (developAllMoves open depth maxDepth) 0 '(0)))
    (else (bestMove open 0 '(0)))))

(define (developAllMoves movesL depth maxDepth)
  (cond
    ((empty? movesL) '())
    (else (cons (develop (first movesL) (add1 depth) maxDepth (possibleMoves (first movesL) 0)) (developAllMoves (rest movesL) (add1 depth) maxDepth)))))

;'bestMove' needs to change according to the player playing next, it needs to seek -inf.0 with O and +inf.0 with X

(define (getGen state gen) ;working
  (cond
    ((= gen 0) state)
    (else (getGen (state-parent state) (sub1 gen)))))


(define (lowestFreeSpotInColumn B column depth)
  (cond
    ((= depth 6) 5)
    ((equal? (getTileAt B column depth) '-) (lowestFreeSpotInColumn B column (add1 depth)))
    (else (sub1 depth))))

(define (opponentMarker marker)
  (cond
    ((equal? marker 'O) 'X)
    (else 'O)))


(define (possibleMoves state column) ;defult column is 0
  (cond
    ((= column 7) '())
    ((move state column) (cons (move state column) (possibleMoves state (add1 column))))
    (else (possibleMoves state (add1 column)))))

(define (testAllMoves depth targetDepth movesL) ;WIP
  (cond
    ((= depth targetDepth) (calcScore movesL))
    ((empty? movesL) 'ERR-NO-MOVES)
    ((empty? (rest movesL)) (testAllMoves (add1 depth) targetDepth (append (rest movesL) (possibleMoves (first movesL) 0))))
    ((not (equal? (state-player (first movesL)) (state-player (second movesL)))) (testAllMoves (add1 depth) targetDepth (append (rest movesL) (possibleMoves (first movesL) 0))))
    (else (testAllMoves depth targetDepth (append (rest movesL) (possibleMoves (first movesL) 0))))))

(define (PvE state)
  (printState state)
  (cond
    ((and (state? (state-parent state)) (win? (state-board state) 0 0 (state-player (state-parent state)))) (print (state-player (state-parent state))) (display " WON"))
    ((empty? (possibleMoves state 0)) (print 'TIE) 0)
    ((equal? (state-player state) 'X) (display "enter your move (0-6) ") (PvE (move state (read))))
    (else (PvE (bestMove (possibleMoves state 0) 0 '(0))))))

(define (playTest state)
  (printState state)
  (cond
    ((and (state? (state-parent state)) (win? (state-board state) 0 0 (state-player (state-parent state)))) (print (state-player (state-parent state))) (display " WON  ") 1)
    ((empty? (possibleMoves state 0)) (print 'TIE) 0)
    (else (playTest (bestMove (possibleMoves state 0) 0 '(0))))))

(define (win? board X Y player)
  (cond
    ((= Y 6) #F)
    ((not (legalTile? X Y)) (win? board 0 (add1 Y) player))
    ((and (< X 4)
          (equal? (list-ref (list-ref board Y) X) player)
          (equal? (list-ref (list-ref board Y) (+ 1 X)) player)
          (equal? (list-ref (list-ref board Y) (+ 2 X)) player)
          (equal? (list-ref (list-ref board Y) (+ 3 X)) player)) #T)
    ((and (< Y 3)
          (equal? (list-ref (list-ref board Y) X) player)
          (equal? (list-ref (list-ref board (+ 1 Y)) X) player)
          (equal? (list-ref (list-ref board (+ 2 Y)) X) player)
          (equal? (list-ref (list-ref board (+ 3 Y)) X) player)) #T)
    ((and (< Y 3) (< X 4)
          (equal? (list-ref (list-ref board Y) X) player)
          (equal? (list-ref (list-ref board (+ 1 Y)) (+ 1 X)) player)
          (equal? (list-ref (list-ref board (+ 2 Y)) (+ 2 X)) player)
          (equal? (list-ref (list-ref board (+ 3 Y)) (+ 3 X)) player)) #T)
    ((and (> Y 3) (< X 4)
          (equal? (list-ref (list-ref board Y) X) player)
          (equal? (list-ref (list-ref board (- Y 1)) (+ 1 X)) player)
          (equal? (list-ref (list-ref board (- Y 2)) (+ 2 X)) player)
          (equal? (list-ref (list-ref board (- Y 3)) (+ 3 X)) player)) #T)
    (else (win? board (add1 X) Y player))))
    
(define (legalTile? X Y)
  (cond
    ((and (< -1 X) (> 7 X) (< -1 Y) (> 6 Y)) #T)
    (else #F)))

(define (printBoard B)
  (cond
   ((not (empty? (rest B))) (println (first B)) (printBoard (rest B)))
   ((empty? (rest B)) (println (first B)))))

(define (findInBoard target B X Y)
  (cond
    ((equal? (getTileAt B (list X Y)) target) (list X Y))
    ((> Y (sub1 (length B))) #F)
    ((= X (sub1 (length (first B)))) (findInBoard target B 0 (add1 Y)))
    (else (findInBoard target B (add1 X) Y))))

(define (findInList target L)
  (cond
    ((empty? L) #F)
    ((equal? (state-board (first L)) (state-board target)) #T)
    (else (findInList target (rest L)))))

(define (updateBoard B Xpos Ypos input)
  (cond
    ((= Ypos 0) (cons (updateCol (first B) Xpos input) (rest B)))
    (else (cons (first B) (updateBoard (rest B) Xpos (sub1 Ypos) input)))))


(define (updateCol L Xpos input)
  (cond
    ((= Xpos 0) (cons input (rest L)))
    (else (cons (first L) (updateCol (rest L) (sub1 Xpos) input)))))


(define (getX input)
  (first input))


(define (getY input)
  (second input))


(define (getTileAt B Xpos Ypos)
  (list-ref (list-ref B Ypos) Xpos))

(define (randomIndexFrom L)
  (list-ref L (random (length L))))

(define (printState state)
  (printBoard (state-board state))
  (display "score: ") (displayln (state-score state))
  (displayln "next turn is:")
  (println (state-player state))
  (newline))

(define (printStates L)
  (cond
    ((empty? L) 'done)
    (else (printState (first L)) (printStates (rest L)))))

(define (runForEach L function input)
  (cond
    ((empty? (rest L)) (function (first L) input))
    (else (append (function (first L) input) (runForEach (rest L) function input)))))
      

(define (tieRate numOfRuns ties wins) ;just for fun... defult is 0 on ties and wins
  (cond
    ((= 0 numOfRuns) (newline) (* (/ ties wins) 100))
    ((= (playTest S) 1) (tieRate (sub1 numOfRuns) ties (add1 wins)))
    (else (tieRate (sub1 numOfRuns) (add1 ties) wins))))

;maybe useful

(define (countAttacks Lindex)
  (cond
    ((= index (length L)) 0)
    (else (+ (attackerCount Lindex) (countAttacks L(add1 index))))))

(define (attackerCount LqueenNum)
  (+ (countDiaAttacks LqueenNum 0) (rowAttacks LqueenNum 0)))

(define (rowAttacks LqueenNum index)
  (cond
    ((= index (length L)) 0)
    ((= index queenNum) (rowAttacks LqueenNum (add1 index)))
    ((= (list-ref LqueenNum) (list-ref Lindex)) (add1 (rowAttacks LqueenNum (add1 index))))
    (else (rowAttacks LqueenNum (add1 index)))))

(define (countDiaAttacks LqueenNum index)
  (cond
    ((= index (length L)) 0)
    ((= index queenNum) (countDiaAttacks LqueenNum (add1 index)))
    ((= (list-ref LqueenNum) (+ (list-ref Lindex) (abs (- index queenNum)))) (add1 (countDiaAttacks LqueenNum (add1 index))))
    ((= (list-ref LqueenNum) (- (list-ref Lindex) (abs (- index queenNum)))) (add1 (countDiaAttacks LqueenNum (add1 index))))
    (else (countDiaAttacks LqueenNum (add1 index)))))
    
  
